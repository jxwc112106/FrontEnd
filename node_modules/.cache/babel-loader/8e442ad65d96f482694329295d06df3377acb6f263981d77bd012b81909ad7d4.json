{"ast":null,"code":"import _slicedToArray from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/root/FrontPlatform/vue-front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.reflect.set.js\";\nimport \"core-js/modules/es.reflect.delete-property.js\";\nimport \"core-js/modules/es.reflect.has.js\";\nimport \"core-js/modules/es.reflect.own-keys.js\";\nimport \"core-js/modules/es.reflect.get-prototype-of.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.object.is-extensible.js\";\nimport { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\nfunction warn(msg) {\n  var _console;\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  (_console = console).warn.apply(_console, [\"[Vue warn] \".concat(msg)].concat(args));\n}\nvar activeEffectScope;\nvar EffectScope = /*#__PURE__*/function () {\n  function EffectScope() {\n    var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, EffectScope);\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  _createClass(EffectScope, [{\n    key: \"active\",\n    get: function get() {\n      return this._active;\n    }\n  }, {\n    key: \"run\",\n    value: function run(fn) {\n      if (this._active) {\n        var currentEffectScope = activeEffectScope;\n        try {\n          activeEffectScope = this;\n          return fn();\n        } finally {\n          activeEffectScope = currentEffectScope;\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn(\"cannot run an inactive effect scope.\");\n      }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n  }, {\n    key: \"on\",\n    value: function on() {\n      activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n  }, {\n    key: \"off\",\n    value: function off() {\n      activeEffectScope = this.parent;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(fromParent) {\n      if (this._active) {\n        var i, l;\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].stop();\n        }\n        for (i = 0, l = this.cleanups.length; i < l; i++) {\n          this.cleanups[i]();\n        }\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].stop(true);\n          }\n        }\n        // nested scope, dereference from parent to avoid memory leaks\n        if (!this.detached && this.parent && !fromParent) {\n          // optimized O(1) removal\n          var last = this.parent.scopes.pop();\n          if (last && last !== this) {\n            this.parent.scopes[this.index] = last;\n            last.index = this.index;\n          }\n        }\n        this.parent = undefined;\n        this._active = false;\n      }\n    }\n  }]);\n  return EffectScope;\n}();\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeEffectScope;\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\"onScopeDispose() is called when there is no active effect scope\" + \" to be associated with.\");\n  }\n}\nvar createDep = function createDep(effects) {\n  var dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nvar wasTracked = function wasTracked(dep) {\n  return (dep.w & trackOpBit) > 0;\n};\nvar newTracked = function newTracked(dep) {\n  return (dep.n & trackOpBit) > 0;\n};\nvar initDepMarkers = function initDepMarkers(_ref) {\n  var deps = _ref.deps;\n  if (deps.length) {\n    for (var i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nvar finalizeDepMarkers = function finalizeDepMarkers(effect) {\n  var deps = effect.deps;\n  if (deps.length) {\n    var ptr = 0;\n    for (var i = 0; i < deps.length; i++) {\n      var dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep[\"delete\"](effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      // clear bits\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nvar targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nvar effectTrackDepth = 0;\nvar trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nvar maxMarkerBits = 30;\nvar activeEffect;\nvar ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'iterate' : '');\nvar MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'Map key iterate' : '');\nvar ReactiveEffect = /*#__PURE__*/function () {\n  function ReactiveEffect(fn) {\n    var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var scope = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, ReactiveEffect);\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n  _createClass(ReactiveEffect, [{\n    key: \"run\",\n    value: function run() {\n      if (!this.active) {\n        return this.fn();\n      }\n      var parent = activeEffect;\n      var lastShouldTrack = shouldTrack;\n      while (parent) {\n        if (parent === this) {\n          return;\n        }\n        parent = parent.parent;\n      }\n      try {\n        this.parent = activeEffect;\n        activeEffect = this;\n        shouldTrack = true;\n        trackOpBit = 1 << ++effectTrackDepth;\n        if (effectTrackDepth <= maxMarkerBits) {\n          initDepMarkers(this);\n        } else {\n          cleanupEffect(this);\n        }\n        return this.fn();\n      } finally {\n        if (effectTrackDepth <= maxMarkerBits) {\n          finalizeDepMarkers(this);\n        }\n        trackOpBit = 1 << --effectTrackDepth;\n        activeEffect = this.parent;\n        shouldTrack = lastShouldTrack;\n        this.parent = undefined;\n        if (this.deferStop) {\n          this.stop();\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // stopped while running itself - defer the cleanup\n      if (activeEffect === this) {\n        this.deferStop = true;\n      } else if (this.active) {\n        cleanupEffect(this);\n        if (this.onStop) {\n          this.onStop();\n        }\n        this.active = false;\n      }\n    }\n  }]);\n  return ReactiveEffect;\n}();\nfunction cleanupEffect(effect) {\n  var deps = effect.deps;\n  if (deps.length) {\n    for (var i = 0; i < deps.length; i++) {\n      deps[i][\"delete\"](effect);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  var _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  var runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nvar shouldTrack = true;\nvar trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  var last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    var depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    var dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    var eventInfo = process.env.NODE_ENV !== 'production' ? {\n      effect: activeEffect,\n      target: target,\n      type: type,\n      key: key\n    } : undefined;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  var shouldTrack = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (process.env.NODE_ENV !== 'production' && activeEffect.onTrack) {\n      activeEffect.onTrack(Object.assign({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  var depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n  var deps = [];\n  if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = _toConsumableArray(depsMap.values());\n  } else if (key === 'length' && isArray(target)) {\n    var newLength = Number(newValue);\n    depsMap.forEach(function (dep, key) {\n      if (key === 'length' || key >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case \"add\" /* TriggerOpTypes.ADD */:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n        break;\n      case \"delete\" /* TriggerOpTypes.DELETE */:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\" /* TriggerOpTypes.SET */:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  var eventInfo = process.env.NODE_ENV !== 'production' ? {\n    target: target,\n    type: type,\n    key: key,\n    newValue: newValue,\n    oldValue: oldValue,\n    oldTarget: oldTarget\n  } : undefined;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (process.env.NODE_ENV !== 'production') {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    var effects = [];\n    var _iterator = _createForOfIteratorHelper(deps),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dep = _step.value;\n        if (dep) {\n          effects.push.apply(effects, _toConsumableArray(dep));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  var effects = isArray(dep) ? dep : _toConsumableArray(dep);\n  var _iterator2 = _createForOfIteratorHelper(effects),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _effect2 = _step2.value;\n      if (_effect2.computed) {\n        triggerEffect(_effect2, debuggerEventExtraInfo);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper(effects),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _effect3 = _step3.value;\n      if (!_effect3.computed) {\n        triggerEffect(_effect3, debuggerEventExtraInfo);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if (process.env.NODE_ENV !== 'production' && effect.onTrigger) {\n      effect.onTrigger(extend({\n        effect: effect\n      }, debuggerEventExtraInfo));\n    }\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\nvar isNonTrackableKeys = /*#__PURE__*/makeMap(\"__proto__,__v_isRef,__isVue\");\nvar builtInSymbols = new Set( /*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n// but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n// function\n.filter(function (key) {\n  return key !== 'arguments' && key !== 'caller';\n}).map(function (key) {\n  return Symbol[key];\n}).filter(isSymbol));\nvar get$1 = /*#__PURE__*/createGetter();\nvar shallowGet = /*#__PURE__*/createGetter(false, true);\nvar readonlyGet = /*#__PURE__*/createGetter(true);\nvar shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nvar arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  var instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {\n    instrumentations[key] = function () {\n      var arr = toRaw(this);\n      for (var i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n      }\n      // we run the method using the original args first (which may be reactive)\n      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      var res = arr[key].apply(arr, args);\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key].apply(arr, _toConsumableArray(args.map(toRaw)));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {\n    instrumentations[key] = function () {\n      pauseTracking();\n      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      var res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  var obj = toRaw(this);\n  track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter() {\n  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n      return shallow;\n    } else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    var targetIsArray = isArray(target);\n    if (!isReadonly) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === 'hasOwnProperty') {\n        return hasOwnProperty;\n      }\n    }\n    var res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\" /* TrackOpTypes.GET */, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nvar set$1 = /*#__PURE__*/createSetter();\nvar shallowSet = /*#__PURE__*/createSetter(true);\nfunction createSetter() {\n  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function set(target, key, value, receiver) {\n    var oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    var result = Reflect.set(target, key, value, receiver);\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  var hadKey = hasOwn(target, key);\n  var oldValue = target[key];\n  var result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  var result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\" /* TrackOpTypes.HAS */, key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\" /* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nvar mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty: deleteProperty,\n  has: has$1,\n  ownKeys: ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n  set: function set(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Set operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n    }\n    return true;\n  },\n  deleteProperty: function deleteProperty(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Delete operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n    }\n    return true;\n  }\n};\nvar shallowReactiveHandlers = /*#__PURE__*/extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nvar shallowReadonlyHandlers = /*#__PURE__*/extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nvar toShallow = function toShallow(value) {\n  return value;\n};\nvar getProto = function getProto(v) {\n  return Reflect.getPrototypeOf(v);\n};\nfunction _get(target, key) {\n  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n    }\n    track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n  }\n  var _getProto = getProto(rawTarget),\n    has = _getProto.has;\n  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\nfunction _has(key) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n  !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n  var proto = getProto(target);\n  var hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n  var _getProto2 = getProto(target),\n    has = _getProto2.has,\n    get = _getProto2.get;\n  var hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n  var oldValue = get.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  var target = toRaw(this);\n  var _getProto3 = getProto(target),\n    has = _getProto3.has,\n    get = _getProto3.get;\n  var hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n  var oldValue = get ? get.call(target, key) : undefined;\n  // forward the operation before queueing reactions\n  var result = target[\"delete\"](key);\n  if (hadKey) {\n    trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  var target = toRaw(this);\n  var hadItems = target.size !== 0;\n  var oldTarget = process.env.NODE_ENV !== 'production' ? isMap(target) ? new Map(target) : new Set(target) : undefined;\n  // forward the operation before queueing reactions\n  var result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    var observed = this;\n    var target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    var rawTarget = toRaw(target);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return target.forEach(function (value, key) {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function () {\n    var target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    var rawTarget = toRaw(target);\n    var targetIsMap = isMap(rawTarget);\n    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    var isKeyOnly = method === 'keys' && targetIsMap;\n    var innerIterator = target[method].apply(target, arguments);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return _defineProperty({\n      // iterator protocol\n      next: function next() {\n        var _innerIterator$next = innerIterator.next(),\n          value = _innerIterator$next.value,\n          done = _innerIterator$next.done;\n        return done ? {\n          value: value,\n          done: done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done: done\n        };\n      }\n    }, Symbol.iterator, function () {\n      return this;\n    });\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function () {\n    if (process.env.NODE_ENV !== 'production') {\n      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? \"on key \\\"\".concat(arguments.length <= 0 ? undefined : arguments[0], \"\\\" \") : \"\";\n      console.warn(\"\".concat(capitalize(type), \" operation \").concat(key, \"failed: target is readonly.\"), toRaw(this));\n    }\n    return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  var mutableInstrumentations = {\n    get: function get(key) {\n      return _get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: _has,\n    add: add,\n    set: set,\n    \"delete\": deleteEntry,\n    clear: clear,\n    forEach: createForEach(false, false)\n  };\n  var shallowInstrumentations = {\n    get: function get(key) {\n      return _get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: _has,\n    add: add,\n    set: set,\n    \"delete\": deleteEntry,\n    clear: clear,\n    forEach: createForEach(false, true)\n  };\n  var readonlyInstrumentations = {\n    get: function get(key) {\n      return _get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has: function has(key) {\n      return _has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n    \"delete\": createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, false)\n  };\n  var shallowReadonlyInstrumentations = {\n    get: function get(key) {\n      return _get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has: function has(key) {\n      return _has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n    \"delete\": createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, true)\n  };\n  var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(function (method) {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\nvar _createInstrumentatio = /* #__PURE__*/createInstrumentations(),\n  _createInstrumentatio2 = _slicedToArray(_createInstrumentatio, 4),\n  mutableInstrumentations = _createInstrumentatio2[0],\n  readonlyInstrumentations = _createInstrumentatio2[1],\n  shallowInstrumentations = _createInstrumentatio2[2],\n  shallowReadonlyInstrumentations = _createInstrumentatio2[3];\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return function (target, key, receiver) {\n    if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nvar mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nvar shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nvar readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nvar shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  var rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    var type = toRawType(target);\n    console.warn(\"Reactive \".concat(type, \" contains both the raw and reactive \") + \"versions of the same object\".concat(type === \"Map\" ? \" as keys\" : \"\", \", \") + \"which can lead to inconsistencies. \" + \"Avoid differentiating between the raw and reactive versions \" + \"of an object and only use the reactive version if possible.\");\n  }\n}\nvar reactiveMap = new WeakMap();\nvar shallowReactiveMap = new WeakMap();\nvar readonlyMap = new WeakMap();\nvar shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1 /* TargetType.COMMON */;\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2 /* TargetType.COLLECTION */;\n    default:\n      return 0 /* TargetType.INVALID */;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value) ? 0 /* TargetType.INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"value cannot be made reactive: \".concat(String(target)));\n    }\n    return target;\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (target[\"__v_raw\" /* ReactiveFlags.RAW */] && !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n    return target;\n  }\n  // target already has corresponding Proxy\n  var existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  // only specific value types can be observed.\n  var targetType = getTargetType(target);\n  if (targetType === 0 /* TargetType.INVALID */) {\n    return target;\n  }\n  var proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n  }\n\n  return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  var raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n  return value;\n}\nvar toReactive = function toReactive(value) {\n  return isObject(value) ? reactive(value) : value;\n};\nvar toReadonly = function toReadonly(value) {\n  return isObject(value) ? readonly(value) : value;\n};\nfunction trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n    if (process.env.NODE_ENV !== 'production') {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: \"get\" /* TrackOpTypes.GET */,\n        key: 'value'\n      });\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n  var dep = ref.dep;\n  if (dep) {\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(dep, {\n        target: ref,\n        type: \"set\" /* TriggerOpTypes.SET */,\n        key: 'value',\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nvar RefImpl = /*#__PURE__*/function () {\n  function RefImpl(value, __v_isShallow) {\n    _classCallCheck(this, RefImpl);\n    this.__v_isShallow = __v_isShallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  _createClass(RefImpl, [{\n    key: \"value\",\n    get: function get() {\n      trackRefValue(this);\n      return this._value;\n    },\n    set: function set(newVal) {\n      var useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n      newVal = useDirectValue ? newVal : toRaw(newVal);\n      if (hasChanged(newVal, this._rawValue)) {\n        this._rawValue = newVal;\n        this._value = useDirectValue ? newVal : toReactive(newVal);\n        triggerRefValue(this, newVal);\n      }\n    }\n  }]);\n  return RefImpl;\n}();\nfunction triggerRef(ref) {\n  triggerRefValue(ref, process.env.NODE_ENV !== 'production' ? ref.value : void 0);\n}\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\nvar shallowUnwrapHandlers = {\n  get: function get(target, key, receiver) {\n    return unref(Reflect.get(target, key, receiver));\n  },\n  set: function set(target, key, value, receiver) {\n    var oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nvar CustomRefImpl = /*#__PURE__*/function () {\n  function CustomRefImpl(factory) {\n    var _this = this;\n    _classCallCheck(this, CustomRefImpl);\n    this.dep = undefined;\n    this.__v_isRef = true;\n    var _factory = factory(function () {\n        return trackRefValue(_this);\n      }, function () {\n        return triggerRefValue(_this);\n      }),\n      get = _factory.get,\n      set = _factory.set;\n    this._get = get;\n    this._set = set;\n  }\n  _createClass(CustomRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      return this._get();\n    },\n    set: function set(newVal) {\n      this._set(newVal);\n    }\n  }]);\n  return CustomRefImpl;\n}();\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (process.env.NODE_ENV !== 'production' && !isProxy(object)) {\n    console.warn(\"toRefs() expects a reactive object but received a plain one.\");\n  }\n  var ret = isArray(object) ? new Array(object.length) : {};\n  for (var key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\nvar ObjectRefImpl = /*#__PURE__*/function () {\n  function ObjectRefImpl(_object, _key, _defaultValue) {\n    _classCallCheck(this, ObjectRefImpl);\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  _createClass(ObjectRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      var val = this._object[this._key];\n      return val === undefined ? this._defaultValue : val;\n    },\n    set: function set(newVal) {\n      this._object[this._key] = newVal;\n    }\n  }, {\n    key: \"dep\",\n    get: function get() {\n      return getDepFromReactive(toRaw(this._object), this._key);\n    }\n  }]);\n  return ObjectRefImpl;\n}();\nfunction toRef(object, key, defaultValue) {\n  var val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\nvar _a$1;\nvar ComputedRefImpl = /*#__PURE__*/function () {\n  function ComputedRefImpl(getter, _setter, isReadonly, isSSR) {\n    var _this2 = this;\n    _classCallCheck(this, ComputedRefImpl);\n    this._setter = _setter;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this[_a$1] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, function () {\n      if (!_this2._dirty) {\n        _this2._dirty = true;\n        triggerRefValue(_this2);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n  }\n  _createClass(ComputedRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n      var self = toRaw(this);\n      trackRefValue(self);\n      if (self._dirty || !self._cacheable) {\n        self._dirty = false;\n        self._value = self.effect.run();\n      }\n      return self._value;\n    },\n    set: function set(newValue) {\n      this._setter(newValue);\n    }\n  }]);\n  return ComputedRefImpl;\n}();\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions) {\n  var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getter;\n  var setter;\n  var onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = process.env.NODE_ENV !== 'production' ? function () {\n      console.warn('Write operation failed: computed value is readonly');\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  var cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (process.env.NODE_ENV !== 'production' && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nvar _a;\nvar tick = /*#__PURE__*/Promise.resolve();\nvar queue = [];\nvar queued = false;\nvar scheduler = function scheduler(fn) {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nvar flush = function flush() {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nvar DeferredComputedRefImpl = /*#__PURE__*/function () {\n  function DeferredComputedRefImpl(getter) {\n    var _this3 = this;\n    _classCallCheck(this, DeferredComputedRefImpl);\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    var compareTarget;\n    var hasCompareTarget = false;\n    var scheduled = false;\n    this.effect = new ReactiveEffect(getter, function (computedTrigger) {\n      if (_this3.dep) {\n        if (computedTrigger) {\n          compareTarget = _this3._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          var valueToCompare = hasCompareTarget ? compareTarget : _this3._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(function () {\n            if (_this3.effect.active && _this3._get() !== valueToCompare) {\n              triggerRefValue(_this3);\n            }\n            scheduled = false;\n          });\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        var _iterator4 = _createForOfIteratorHelper(_this3.dep),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var e = _step4.value;\n            if (e.computed instanceof DeferredComputedRefImpl) {\n              e.scheduler(true /* computedTrigger */);\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      _this3._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _createClass(DeferredComputedRefImpl, [{\n    key: \"_get\",\n    value: function _get() {\n      if (this._dirty) {\n        this._dirty = false;\n        return this._value = this.effect.run();\n      }\n      return this._value;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      trackRefValue(this);\n      // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n      return toRaw(this)._get();\n    }\n  }]);\n  return DeferredComputedRefImpl;\n}();\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };","map":{"version":3,"names":["extend","isArray","isMap","isIntegerKey","hasOwn","isSymbol","isObject","hasChanged","makeMap","capitalize","toRawType","def","isFunction","NOOP","warn","msg","_console","_len","arguments","length","args","Array","_key2","console","apply","concat","activeEffectScope","EffectScope","detached","undefined","_classCallCheck","_active","effects","cleanups","parent","index","scopes","push","_createClass","key","get","value","run","fn","currentEffectScope","process","env","NODE_ENV","on","off","stop","fromParent","i","l","last","pop","effectScope","recordEffectScope","effect","scope","active","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","_ref","deps","finalizeDepMarkers","ptr","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","options","_effect","lazy","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","depsMap","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","onTrack","Object","assign","trigger","newValue","oldValue","oldTarget","_toConsumableArray","values","newLength","Number","forEach","triggerEffects","_iterator","_createForOfIteratorHelper","_step","s","done","err","e","f","_iterator2","_step2","computed","triggerEffect","_iterator3","_step3","allowRecurse","onTrigger","getDepFromReactive","object","_a","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","map","get$1","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","_len2","_key3","res","_len3","_key4","hasOwnProperty","obj","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","readonly","reactive","set$1","createSetter","shallowSet","isShallow","hadKey","result","deleteProperty","has$1","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","_getProto","wrap","toReadonly","toReactive","call","size","proto","_getProto2","checkIdentityKeys","deleteEntry","_getProto3","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","_defineProperty","next","_innerIterator$next","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","_createInstrumentatio","_createInstrumentatio2","_slicedToArray","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_this","_factory","_get","_set","customRef","toRefs","ret","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","defaultValue","_a$1","ComputedRefImpl","getter","_setter","isSSR","_this2","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","cRef","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","_this3","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","_iterator4","_step4","deferredComputed"],"sources":["/root/FrontPlatform/vue-front/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this._active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    get active() {\n        return this._active;\n    }\n    run(fn) {\n        if (this._active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this._active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this._active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        extend(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = (process.env.NODE_ENV !== 'production')\n            ? { effect: activeEffect, target, type, key }\n            : undefined;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newLength) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* TriggerOpTypes.ADD */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if (isIntegerKey(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* TriggerOpTypes.DELETE */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* TriggerOpTypes.SET */:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = (process.env.NODE_ENV !== 'production')\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : undefined;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {\n                triggerEffects(deps[0]);\n            }\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {\n            triggerEffects(createDep(effects));\n        }\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    const effects = isArray(dep) ? dep : [...dep];\n    for (const effect of effects) {\n        if (effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n    for (const effect of effects) {\n        if (!effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n        if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\n            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\n        }\n        if (effect.scheduler) {\n            effect.scheduler();\n        }\n        else {\n            effect.run();\n        }\n    }\n}\nfunction getDepFromReactive(object, key) {\n    var _a;\n    return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => Symbol[key])\n    .filter(isSymbol));\nconst get$1 = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction hasOwnProperty(key) {\n    const obj = toRaw(this);\n    track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n    return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = isArray(target);\n        if (!isReadonly) {\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n        const res = Reflect.get(target, key, receiver);\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - skip unwrap for Array + integer key.\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n        if (isObject(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set$1 = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow) {\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = isArray(target) && isIntegerKey(key)\n            ? Number(key) < target.length\n            : hasOwn(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n            }\n            else if (hasChanged(value, oldValue)) {\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has$1(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get: get$1,\n    set: set$1,\n    deleteProperty,\n    has: has$1,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n    }\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n        }\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n    }\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n    }\n    return this;\n}\nfunction set(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n    }\n    else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = (process.env.NODE_ENV !== 'production')\n        ? isMap(target)\n            ? new Map(target)\n            : new Set(target)\n        : undefined;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = isMap(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n            return target;\n        }\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = toRawType(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only specific value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(dep, {\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {\n            triggerEffects(dep);\n        }\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n    get dep() {\n        return getDepFromReactive(toRaw(this._object), this._key);\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a$1;\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this[_a$1] = false;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = (process.env.NODE_ENV !== 'production')\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : NOOP;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if ((process.env.NODE_ENV !== 'production') && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}